# Sidekick-Presentation-Framework
---------------------------------
This is a framework that attempts to establish a consistent architecture for presentation/i-vis type applications sharing similar requirements in layout, function and structure. The code base is split into sections that define a set of features relevant to the scope of the section. The lowest level consists of a basic sliding carousel which manages basic swipe/drag interactivity and transition between individual slides. Slides themselves are represented as individual object instances which can hold custom data unique to that slide. Extending this basic carousel is a generic project structure which manages and handles multiple sections with multiple slides, linking navigation to slide management on a presentation level, initialization and project status caching. This is wrapped by a broader API known as Wingman that is extendable to include more abstract, generalized tasks.
The framework relies on a JSON file to define the data structure of the presentation. The framework is dependent on this general structure but can easily be extended to include additional properties as necessary. The presentation is divided into an array of section objects which stores information about the section as well as a subproperty storing an array of slide objects similarly structured to a section. Each slide object has a 'customproperties' property which is an object that auto-assigns all child properties to the slide. Additionally, each slide object has an 'events' property which represents an object defining custom event handlers. the key is the event name, currently supporting ['load','focus','blur','transitionto' and 'transitionfrom'] - while the value is a pre-defined named global function represented as a string. this function is executed at the time the custom event fires. A 'next' or 'prev' property can be set to an object representing a jumpto redirect to a different slide and section or different Key Message entirely. This fires in priority over a typical left/right cycling of the slide carousel.
Within the main.js file included in the project structure, the project instance is defined. This is largely where extensions of the base functions and features of the framework should live. When the DOM content is ready, the project instance must call its prototypal 'build()' method, including at least the HTML object reference or element ID of the slide carousel container, and optionally a similar reference for a main navigation container, and a callback to fire once finished executing. the JSON data is returned as an argument to the callback method. Slides are loaded in asynchronously and accrue a load count once the content has finished being injected into the main document. Once all slides load, an optional callback method is triggered, which redirects to a global static function labeled 'mainInit()' within the main.js file by default. This is where all content-dependent script must first be initialized to ensure the objects exist within the DOM upon execution.
The directory structure is broken out into content folders specific to the function of the content. CSS, JS, JSON data, Fonts and Slide content all have their designated folders. Slide specific content placement can be variable by defining that content's base location within that slide object within the slidestructure.json setup. This location definition sets a root directory reference for all related content associated with that slide. Each slide can have linked scripts and stylesheets or can embed script into its head element to be injected into the main document. To ensure the script fires when the page becomes ready, wrap the script or its main functions within an init function triggered by 'mainInit()' within the main.js file. Keeping content specific to that slide defined within the slide's head element keeps that script and styling clearly associated with the content on that page, HOWEVER: that script will be injected into the main document and can affect script and styles from other sections and slides! It is therefore recommended to encapsulate scripts and styles appropriately to ensure they remain within the intended scope.
